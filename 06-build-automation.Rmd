# Build automation {#chptr-workflow-automation}

Large projects can be a pain to manage. Small changes in one of your files may
require recompilation of software or a re-analysis of your data.
Automation of such a processes is the purpose of build automation tools, thereby
simplifying your workflow. There are many build automation tools available, but
here we will mainly discuss build automation using Makefiles. We illustrate
build automation with an example project. This example project has its own 
Github repository: https://github.com/rr-mrc-bsu/build-automation-example. It
might help to occassionally look at the example project and try to play 
around with it. The rest of the project will be structured as follows: We start
with an introduction of the make software and its workhorse, the Makefile. 

[add rest of chapter description]

## Makefiles

Most research projects consist of several different connected components. 
For example, the end product might be a manuscipt, which depends on intermediate
components such as a data analysis script and an R package. In this case, 
the manuscript depends on the data analysis script, which in turn depends on the
R package. Such a hierarchy implies that every time a file changes, all files 
downstream in the hierarchy require updating as well. For example, 
we might make a change to an R package function. This might change the outcome 
of the a data analysis script, and as a result, we'd have to re-run the data 
analysis script. Likewise, the outcome of the data analysis might change the 
manuscript we're writing, so we'd 
have to re-compile that as well. In large projects, this quickly becomes tedious
and difficult to maintain by hand. Luckily there is software available to 
streamline this process.

Our example project of this chapter is contained in the following directory:
```{bash example-directory, eval=FALSE, echo=TRUE}
./
|   # the folder holding raw data
├── data 
│   └── iris.csv # jus a .csv version of the famous iris data set
|   
|   # markdown files for reports
├── reports
│   ├── data-preparation.Rmd
│   └── analysis.Rmd
|
|   # additional R scripts for stuff that is too ugly/long running for .Rmd
├── scripts
│   └── load-data.R
|   
├── .gitignore # define what we ignore in this repository
├── .travis.yml # cf. chapter 'continuous integration'
├── DESCRIPTION # makes Travis-CI believe this is an R package, cf. chapter 'continuous integration'
├── Makefile # actual makefile defining the individual build steps
└── README.md # the file you are looking at right now
```

[to do: make diagram with DiagrammeR]

Re-running, -building, and -compiling all the files after we made a change to 
the anyone of the intermediate files would be a tedious task. Ideally, we would
like to have a command that re-runs/compiles/builds the different files 
everytime an upstream change is made. This is exactly what the GNU software Make 
does. Make works through a Makefile, a file that describes how a target file,
depends on its dependencies, and how these in turn on their dependencies, and so
on. If a Makefile is run, a file is compiled if any of its dependencies has 
changed since the last time the file was compiled. In other words, the Makefile
starts at the top of the hierarchy and updates a file if its creation time is 
older than the creation time of its dependencies. In our example in Figure
\@ref(fig:workflow-diagram), if we make a change to the functions.R file, we
trigger the recompilation of the recompilation of the r-package.tar.gz file, 
which in turn triggers a rerunning of the analysis.R and simulation.R scripts,
and so on, until all files are up to date again.

[add example Makefile]
