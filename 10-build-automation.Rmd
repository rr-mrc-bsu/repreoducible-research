# Build automation {#chptr-workflow-automation}

Large projects can be a pain to manage. Small changes in one of your files may
require recompilation of software or a re-analysis of your data.
Automation of such a processes is the purpose of build automation tools, thereby
simplifying your workflow. There are many build automation tools available, but
here we will mainly discuss build automation using Makefiles. We illustrate
build automation with an example project. This example project has its own 
Github repository: https://github.com/rr-mrc-bsu/build-automation-example. It
might help to occassionally look at the example project and try to play 
around with it. The rest of the project will be structured as follows: We start
with an introduction of the make software and its workhorse, the Makefile. 

[add rest of chapter description]

## Project workflow

Most research projects consist of several different connected components. 
For example, the end product might be a manuscipt, which depends on intermediate
components such as the output of the data preparation and data analysis. 
In this case, 
the manuscript depends on the analysis.Rmd file, which in turn depends on the
data-preparation.Rmd file. Such a hierarchy implies that every time a file
changes, all files 
downstream in the hierarchy require updating as well. For example, 
we might make a change to our data preparation. This might change the outcome 
of the a data analysis, and as a result, we'd have to re-compile the manuscript.
In large projects, this quickly becomes tedious
and difficult to maintain by hand. Luckily there is software available to 
streamline this process.

A directory containing the example above might look something like this:
```{bash example-directory, eval=FALSE, echo=TRUE}
./
|   # the folder holding raw data
├── data 
│   └── iris.csv # jus a .csv version of the famous iris data set
|   
|   # markdown files for reports and documents
├── docs
│   ├── analysis.Rmd # an intermediate analysis report
│   ├── manuscript.Rmd # the eventual manuscript
│   └── presentation.Rmd # a conference presentation with intermediate results
|
|   # additional R scripts for stuff that is too ugly/long running for .Rmd
├── scripts
│   ├── load-data.R
│   ├── data-preparation.R # the file that prepares our data
│   └── simulation.R # a small simulation study for in the manuscript
|   
├── .gitignore # define what we ignore in this repository
├── .travis.yml # cf. chapter 'continuous integration'
├── DESCRIPTION # makes Travis-CI believe this is an R package, cf. chapter 'continuous integration'
├── Makefile # actual makefile defining the individual build steps
├── build-automation-example.Rproj # makes it easier to work in Rstudio
└── README.md # describes the project, this is shown on a Github repo

```
Actually, this is the project in our example repository. The dependencies 
between the files in our project may be represented in a flowchart something like this:
```{r example-project-flowchart, eval=TRUE, echo=FALSE}
library(DiagrammeR)
grViz("digraph rmarkdown {
'iris.csv' -> 'data-preparation.R'
'data-preparation.R' -> 'analysis.Rmd'
'simulation.R' -> 'manuscript.Rmd'
'analysis.Rmd' -> 'manuscript.Rmd'
}", height=200)
```

Re-running, -building, and -compiling all the files after we made a change to 
the anyone of the intermediate files would be a tedious task. Ideally, we would
like to have a command that re-runs/compiles/builds the different files 
everytime an upstream change is made. This is exactly what the GNU software Make
does. Make works through a Makefile, a file that describes how a target file,
depends on its dependencies, and how these in turn on their dependencies, and so
on.

## Makefile
If a Makefile is run with the command `make`, a file is compiled if any of its
dependencies have 
changed since the last time the file was compiled. In other words, the Makefile
starts at the top of the hierarchy and rebuilds a file if it was created time
before any of its dependencies. A Makefile is composed of a 
number of rules. Each rule is composed of a target, its prerequisites, and a
recipe. Each target is separated from its prerequisites by a colon. The recipe
starts on a new line with a tab:
```{bash general-makefile, eval=FALSE, echo=TRUE}
target: prerequisite1 prerequisite2
    recipe
    ...
```
In the simplest case, the target is a file, and the prerequisites are the files
on which it depends. The recipte then describes how one would create the target
from the prerequisites. 

In our example in Figure
\@ref(example-project-flowchart), a Makefile could look something like this:
```{bash example-makefile, eval=FALSE, echo=TRUE}
all: docs/manuscript.pdf docs/analysis.html

clean:
	rm -rf output # remove complete output
	(cd reports && rm -f !\(*.Rmd\)) # remove all non-.Rmd files

docs/data-preparation.html: data/iris.csv docs/data-preparation.Rmd
	# render the .Rmd file, all paths must be relative to .Rmd!
	Rscript -e "rmarkdown::render(\
	input       = 'docs/data-preparation.Rmd',\
	output_file = 'data-preparation.html',\
	output_dir  = 'docs',\
	params      = list(datafile='../data/iris.rds', outputpath = '../output')"

docs/analysis.html: data/iris.rds docs/analysis.Rmd
	# render the .Rmd file, all paths must be relative to .Rmd!
	Rscript -e "rmarkdown::render(\
	input       = 'docs/analysis.Rmd',\
	output_file = 'analysis.html',\
	output_dir  = 'docs',\
	params      = list(datafile    = '../output/iris_mod.rds', 
	                   outputpath  = '../output'))"
```
This might seem daunting at first, but don't worry we'll go over the file part
by part.

## Pattern rules

## Automatic variables
